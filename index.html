<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯æ„›è²“å’ªç‚¸å½ˆè¶…äºº | Cat Bomber</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Varela+Round&display=swap');

        :root {
            --bg-color: #FFF3E0;
            --ui-bg: #FFCCBC;
            --text-color: #5D4037;
            --accent: #FF7043;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Varela Round', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        h1 {
            font-family: 'Fredoka One', cursive;
            color: var(--accent);
            text-shadow: 2px 2px 0px #FFF, 4px 4px 0px rgba(0,0,0,0.1);
            margin: 10px 0;
            font-size: 2.5rem;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border-radius: 12px;
            overflow: hidden;
            background: #fff;
        }

        canvas {
            display: block;
            background-color: #FBE9E7; /* åœ°æ¿åº•è‰² */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            font-weight: bold;
            font-size: 1.1rem;
            z-index: 10;
            border-bottom: 2px solid var(--ui-bg);
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 243, 224, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(2px);
        }

        .hidden {
            display: none !important;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Fredoka One', cursive;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 0 #E64A19;
            transition: transform 0.1s, box-shadow 0.1s;
            margin-top: 20px;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 1px 0 #E64A19;
        }

        button:hover {
            filter: brightness(1.1);
        }

        .msg-title {
            font-family: 'Fredoka One', cursive;
            font-size: 3rem;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .msg-sub {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .instructions {
            margin-top: 30px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: left;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }
        
        .key {
            display: inline-block;
            background: #eee;
            padding: 2px 6px;
            border-radius: 4px;
            border-bottom: 2px solid #ccc;
            font-size: 0.9em;
            font-weight: bold;
        }

        /* éŸ¿æ‡‰å¼ */
        @media (max-width: 600px) {
            h1 { font-size: 1.5rem; }
            #game-container { transform: scale(0.9); }
        }
    </style>
</head>
<body>

    <h1>ğŸ± Cat Bomber</h1>

    <div id="game-container">
        <div id="ui-layer">
            <div class="hud-item">
                <span>ğŸ’£</span> <span id="hud-bomb">1</span>
            </div>
            <div class="hud-item">
                <span>ğŸ”¥</span> <span id="hud-power">1</span>
            </div>
            <div class="hud-item">
                <span>ğŸ‘Ÿ</span> <span id="hud-speed">1</span>
            </div>
            <div class="hud-item" style="color: #E57373;">
                <span>ğŸ‘¾</span> <span id="hud-enemies">0</span>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>

        <div id="overlay">
            <div class="msg-title" id="overlay-title">Cat Bomber</div>
            <div class="msg-sub" id="overlay-sub">Help the kitty find the exit!</div>
            <button id="start-btn">START GAME</button>
            
            <div class="instructions">
                <p><span class="key">â†‘</span> <span class="key">â†“</span> <span class="key">â†</span> <span class="key">â†’</span> ç§»å‹• Move</p>
                <p><span class="key">SPACE</span> æ”¾ç‚¸å½ˆ Bomb</p>
                <p>ç›®æ¨™ï¼šæ‰“æ•—æ‰€æœ‰æ•µäººä¸¦æ‰¾åˆ°å‡ºå£é–€ ğŸšª</p>
            </div>
        </div>
    </div>

<script>
/**
 * Cat Bomber Game Logic
 */

// --- éŠæˆ²å¸¸æ•¸ ---
const TILE_SIZE = 40; // æ ¼å­å¤§å°
const COLS = 13;
const ROWS = 11;
const WIDTH = COLS * TILE_SIZE;
const HEIGHT = ROWS * TILE_SIZE;

// --- å¯¦é«”é¡å‹ ---
const TYPES = {
    FLOOR: 0,
    WALL_HARD: 1, // é‹¼éµç‰†ï¼ˆä¸å¯ç ´å£ï¼‰
    WALL_SOFT: 2, // ç£šç‰†ï¼ˆå¯ç ´å£ï¼‰
    BOMB: 3,
    EXIT: 9,
};

// --- ç•«å¸ƒè¨­å®š ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = WIDTH;
canvas.height = HEIGHT;

// --- UI å…ƒç´  ---
const hudBomb = document.getElementById('hud-bomb');
const hudPower = document.getElementById('hud-power');
const hudSpeed = document.getElementById('hud-speed');
const hudEnemies = document.getElementById('hud-enemies');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlay-title');
const overlaySub = document.getElementById('overlay-sub');
const startBtn = document.getElementById('start-btn');

// --- éŸ³æ•ˆç³»çµ± (Web Audio API) ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = new AudioCtx();

const playSound = (type) => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === 'plant') {
        // æ”¾ç‚¸å½ˆï¼šçŸ­ä¿ƒçš„å•µè²
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'explode') {
        // çˆ†ç‚¸ï¼šå™ªéŸ³ (æ¨¡æ“¬) - é€™è£¡ç”¨ä½é »éœ‡ç›ªæ¨¡æ“¬
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'item') {
        // é“å…·ï¼šæ¸…è„†éˆ´è²
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.setValueAtTime(1200, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'win') {
        // å‹åˆ©ï¼šå¤§èª¿ç¶éŸ³
        osc.type = 'triangle';
        gainNode.gain.value = 0.3;
        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.connect(g);
            g.connect(audioCtx.destination);
            o.frequency.value = freq;
            g.gain.setValueAtTime(0.2, now + i*0.1);
            g.gain.exponentialRampToValueAtTime(0.01, now + i*0.1 + 0.3);
            o.start(now + i*0.1);
            o.stop(now + i*0.1 + 0.3);
        });
    } else if (type === 'die') {
        // å¤±æ•—ï¼šæ»‘è½éŸ³
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.5);
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.linearRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
    }
};

// --- éŠæˆ²ç‹€æ…‹ ---
let lastTime = 0;
let gameRunning = false;
let map = []; // äºŒç¶­é™£åˆ—
let bombs = [];
let explosions = [];
let items = [];
let enemies = [];
let particles = [];
let exitPos = {x: 0, y: 0, revealed: false};

// ç©å®¶ç‰©ä»¶
const player = {
    x: TILE_SIZE,
    y: TILE_SIZE,
    radius: TILE_SIZE * 0.4,
    speed: 2, // åŸºç¤é€Ÿåº¦
    dx: 0,
    dy: 0,
    maxBombs: 1,
    bombRange: 1,
    hasKick: false,
    speedMulti: 1,
    direction: 'down',
    walkFrame: 0,
    dead: false
};

// --- è¼¸å…¥æ§åˆ¶ ---
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Space' && gameRunning && !player.dead) {
        placeBomb();
    }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// --- åˆå§‹åŒ–åœ°åœ– ---
function initMap() {
    map = [];
    let softBlocks = [];

    // ç”Ÿæˆç‰†å£èˆ‡åœ°æ¿
    for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
            // é‚Šç•Œå¿…å®šæ˜¯ç¡¬ç‰†
            if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
                row.push(TYPES.WALL_HARD);
            } 
            // æ£‹ç›¤æ ¼ç¡¬ç‰† (æ¯éš”ä¸€æ ¼)
            else if (r % 2 === 0 && c % 2 === 0) {
                row.push(TYPES.WALL_HARD);
            } 
            // ç©å®¶å‡ºç”Ÿé» (å·¦ä¸Šè§’) ä¿ç•™ç©ºåœ°
            else if ((r === 1 && c === 1) || (r === 1 && c === 2) || (r === 2 && c === 1)) {
                row.push(TYPES.FLOOR);
            } 
            // å…¶ä»–åœ°æ–¹éš¨æ©Ÿç”Ÿæˆè»Ÿç‰†
            else {
                if (Math.random() < 0.4) { // 40% æ©Ÿç‡ç”Ÿæˆç£šç‰†
                    row.push(TYPES.WALL_SOFT);
                    softBlocks.push({r, c});
                } else {
                    row.push(TYPES.FLOOR);
                }
            }
        }
        map.push(row);
    }

    // æ”¾ç½®å‡ºå£ (è—åœ¨æŸå€‹è»Ÿç‰†ä¸‹ï¼Œå¦‚æœæ²’æœ‰è»Ÿç‰†å‰‡éš¨æ©Ÿæ”¾)
    if (softBlocks.length > 0) {
        const exitIdx = Math.floor(Math.random() * softBlocks.length);
        exitPos = { x: softBlocks[exitIdx].c, y: softBlocks[exitIdx].r, revealed: false };
        // å¾åˆ—è¡¨ä¸­ç§»é™¤ï¼Œé¿å…å‡ºå£è·Ÿé“å…·é‡ç–Š (é›–ç„¶é‡ç–Šä¹Ÿæ²’é—œä¿‚ï¼Œé“å…·å„ªå…ˆ)
        softBlocks.splice(exitIdx, 1);
    } else {
        exitPos = { x: COLS-2, y: ROWS-2, revealed: false };
    }

    // æ”¾ç½®é“å…·
    // ç°¡å–®è¦å‰‡ï¼šéš¨æ©Ÿé¸å¹¾å€‹ç£šå¡Šå¡é“å…·
    const itemsToSpawn = [
        {type: 'bomb', count: 3}, 
        {type: 'fire', count: 3}, 
        {type: 'speed', count: 2}, 
        {type: 'kick', count: 1}
    ];

    itemsToSpawn.forEach(it => {
        for(let i=0; i<it.count; i++) {
            if (softBlocks.length > 0) {
                const idx = Math.floor(Math.random() * softBlocks.length);
                const pos = softBlocks[idx];
                items.push({
                    x: pos.c, y: pos.r, 
                    type: it.type, 
                    hidden: true // éš±è—åœ¨ç£šç‰†ä¸‹
                });
                softBlocks.splice(idx, 1);
            }
        }
    });

    // ç”Ÿæˆæ•µäºº
    enemies = [];
    let enemyCount = 3 + Math.floor(Math.random() * 2); // 3-4 å€‹æ•µäºº
    let safeZone = 3; // é é›¢ç©å®¶å¹¾æ ¼
    
    while(enemies.length < enemyCount) {
        let er = Math.floor(Math.random() * ROWS);
        let ec = Math.floor(Math.random() * COLS);
        // å¿…é ˆæ˜¯ç©ºåœ°ï¼Œä¸”ä¸åœ¨ç©å®¶é™„è¿‘
        if (map[er][ec] === TYPES.FLOOR && (er + ec > safeZone)) {
            enemies.push({
                x: ec * TILE_SIZE + TILE_SIZE/2,
                y: er * TILE_SIZE + TILE_SIZE/2,
                r: er, c: ec,
                dir: Math.floor(Math.random()*4), // 0:up, 1:down, 2:left, 3:right
                speed: 1 + Math.random() * 0.5,
                type: Math.random() > 0.5 ? 'slime' : 'chicken',
                dead: false
            });
        }
    }
}

// --- é‡ç½®éŠæˆ² ---
function resetGame() {
    bombs = [];
    explosions = [];
    items = [];
    particles = [];
    
    // é‡ç½®ç©å®¶
    player.x = TILE_SIZE * 1.5;
    player.y = TILE_SIZE * 1.5;
    player.maxBombs = 1;
    player.bombRange = 1; // çˆ†ç‚¸åŠå¾‘ (æ ¼)
    player.speedMulti = 1;
    player.hasKick = false;
    player.dead = false;
    player.walkFrame = 0;

    initMap();
    updateHUD();
    gameRunning = true;
    overlay.classList.add('hidden');
    requestAnimationFrame(gameLoop);
}

// --- è¼”åŠ©å‡½å¼ ---
function getTile(col, row) {
    if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return TYPES.WALL_HARD;
    return map[row][col];
}

function setTile(col, row, type) {
    if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
        map[row][col] = type;
    }
}

// åƒç´ è½‰æ ¼å­åº§æ¨™
function toGrid(px) {
    return Math.floor(px / TILE_SIZE);
}

// å°é½Šæ ¼å­ä¸­å¿ƒ
function snapCenter(val) {
    return Math.floor(val / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
}

// åœ“å½¢/çŸ©å½¢ç¢°æ’æª¢æ¸¬
function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
    let testX = cx;
    let testY = cy;
    if (cx < rx) testX = rx;
    else if (cx > rx + rw) testX = rx + rw;
    if (cy < ry) testY = ry;
    else if (cy > ry + rh) testY = ry + rh;
    let distX = cx - testX;
    let distY = cy - testY;
    return (distX * distX + distY * distY) <= (cr * cr);
}

// --- ç¹ªåœ–å‡½å¼ (Canvas Drawing) ---

function drawRoundedRect(x, y, w, h, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.fill();
}

function drawCat(x, y, dir, frame) {
    // èº«é«” bobbing å‹•ç•«
    let bob = Math.sin(frame * 0.2) * 2;
    
    ctx.save();
    ctx.translate(x, y + bob);

    // é™°å½±
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath();
    ctx.ellipse(0, 16, 12, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // èº«é«”
    ctx.fillStyle = "#FFAB91"; // æ©˜è‰²
    drawRoundedRect(-12, -10, 24, 20, 8, "#FFAB91");

    // è‚šè‚š
    ctx.fillStyle = "#FFCCBC";
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fill();

    // é ­
    ctx.fillStyle = "#FFAB91"; // æ©˜è‰²
    ctx.beginPath();
    ctx.arc(0, -12, 16, 0, Math.PI * 2);
    ctx.fill();

    // è€³æœµ
    ctx.beginPath();
    ctx.moveTo(-12, -20);
    ctx.lineTo(-4, -24);
    ctx.lineTo(-14, -8);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(12, -20);
    ctx.lineTo(4, -24);
    ctx.lineTo(14, -8);
    ctx.fill();

    // è‡‰éƒ¨
    ctx.fillStyle = "#3E2723";
    // çœ¼ç›
    if (player.dead) {
        // X X çœ¼
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#3E2723";
        ctx.beginPath(); ctx.moveTo(-6, -14); ctx.lineTo(-2, -10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-2, -14); ctx.lineTo(-6, -10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(6, -14); ctx.lineTo(2, -10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(2, -14); ctx.lineTo(6, -10); ctx.stroke();
    } else {
        ctx.beginPath(); ctx.arc(-5, -12, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(5, -12, 2, 0, Math.PI * 2); ctx.fill();
    }
    
    // é¼»å­å˜´å·´
    ctx.fillStyle = "#D81B60";
    ctx.beginPath(); ctx.arc(0, -8, 1.5, 0, Math.PI * 2); ctx.fill();
    
    ctx.beginPath();
    ctx.moveTo(0, -8);
    ctx.lineTo(-2, -5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, -8);
    ctx.lineTo(2, -5);
    ctx.stroke();

    // é¬é¬š
    ctx.strokeStyle = "#3E2723";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(-12, -10); ctx.lineTo(-18, -12); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-12, -8); ctx.lineTo(-18, -6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(12, -10); ctx.lineTo(18, -12); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(12, -8); ctx.lineTo(18, -6); ctx.stroke();

    ctx.restore();
}

function drawEnemy(e) {
    ctx.save();
    ctx.translate(e.x, e.y);
    let bob = Math.sin(Date.now() / 150) * 3;
    
    // é™°å½±
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath(); ctx.ellipse(0, 14, 10, 4, 0, 0, Math.PI*2); ctx.fill();

    if (e.type === 'slime') {
        // å²èŠå§† (è—è‰²)
        ctx.fillStyle = "#42A5F5";
        ctx.beginPath();
        ctx.arc(0, -5 + bob, 14, Math.PI, 0); // ä¸ŠåŠåœ“
        ctx.lineTo(14, 5 + bob);
        ctx.quadraticCurveTo(0, 15+bob, -14, 5+bob);
        ctx.fill();
        
        // è‡‰
        ctx.fillStyle = "white";
        ctx.beginPath(); ctx.arc(-4, -5+bob, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -5+bob, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "black";
        ctx.beginPath(); ctx.arc(-4, -5+bob, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -5+bob, 1, 0, Math.PI*2); ctx.fill();
    } else {
        // å°é› (é»ƒè‰²)
        ctx.fillStyle = "#FFEE58";
        ctx.beginPath(); ctx.arc(0, 0 + bob, 13, 0, Math.PI*2); ctx.fill();
        // é›å† 
        ctx.fillStyle = "#EF5350";
        ctx.beginPath(); ctx.arc(0, -12+bob, 4, 0, Math.PI*2); ctx.fill();
        // å˜´
        ctx.fillStyle = "#FF7043";
        ctx.beginPath(); ctx.moveTo(0, 0+bob); ctx.lineTo(6, 3+bob); ctx.lineTo(0, 6+bob); ctx.fill();
        // çœ¼
        ctx.fillStyle = "black";
        ctx.beginPath(); ctx.arc(-4, -3+bob, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -3+bob, 2, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
}

function drawMap() {
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            let x = c * TILE_SIZE;
            let y = r * TILE_SIZE;
            let type = map[r][c];

            // åœ°æ¿ (æ ¼ç·š)
            ctx.strokeStyle = "#F6D6D6";
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

            if (type === TYPES.WALL_HARD) {
                // ç¡¬ç‰†ï¼šç°è‰²ç«‹é«”
                ctx.fillStyle = "#B0BEC5";
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = "#CFD8DC"; // High light
                ctx.fillRect(x, y, TILE_SIZE-4, TILE_SIZE-4);
                ctx.fillStyle = "#90A4AE"; // Shadow
                ctx.fillRect(x+4, y+4, TILE_SIZE-4, TILE_SIZE-4);
                ctx.fillStyle = "#B0BEC5"; // Face
                ctx.fillRect(x+2, y+2, TILE_SIZE-4, TILE_SIZE-4);
            } 
            else if (type === TYPES.WALL_SOFT) {
                // ç£šç‰†ï¼šæ£•è‰²
                ctx.fillStyle = "#A1887F";
                ctx.fillRect(x+1, y+1, TILE_SIZE-2, TILE_SIZE-2);
                // ç£šç´‹
                ctx.fillStyle = "#8D6E63";
                ctx.fillRect(x+2, y+5, 16, 8);
                ctx.fillRect(x+20, y+5, 16, 8);
                ctx.fillRect(x+5, y+18, 16, 8);
                ctx.fillRect(x+24, y+18, 12, 8);
                ctx.fillRect(x+2, y+30, 16, 8);
                ctx.fillRect(x+20, y+30, 16, 8);
            }
        }
    }

    // ç•«å‡ºå£
    if (exitPos.revealed) {
        let x = exitPos.x * TILE_SIZE;
        let y = exitPos.y * TILE_SIZE;
        ctx.fillStyle = "#333";
        ctx.fillRect(x+5, y+5, 30, 30);
        ctx.fillStyle = "#4FC3F7"; // é–€å…§å…‰
        ctx.fillRect(x+8, y+8, 24, 24);
        ctx.font = "20px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("EXIT", x+20, y+20);
    }
}

function drawBombs() {
    bombs.forEach(b => {
        let x = b.c * TILE_SIZE + TILE_SIZE/2;
        let y = b.r * TILE_SIZE + TILE_SIZE/2;
        
        // ç‚¸å½ˆæœ¬é«”
        ctx.fillStyle = "#212121";
        ctx.beginPath();
        // è„ˆå‹•æ•ˆæœ
        let scale = 1 + Math.sin(Date.now() / 100) * 0.1;
        ctx.arc(x, y + 2, 14 * scale, 0, Math.PI * 2);
        ctx.fill();

        // é«˜å…‰
        ctx.fillStyle = "#616161";
        ctx.beginPath();
        ctx.arc(x - 5, y - 5, 4 * scale, 0, Math.PI * 2);
        ctx.fill();

        // å°ç«ç·š
        ctx.strokeStyle = "#FFAB00";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, y - 12);
        ctx.quadraticCurveTo(x + 5, y - 18, x + 8, y - 14);
        ctx.stroke();

        // ç«èŠ±
        if (Math.floor(Date.now() / 50) % 2 === 0) {
            ctx.fillStyle = "#FF5722";
            ctx.beginPath();
            ctx.arc(x+8, y-14, 3, 0, Math.PI*2);
            ctx.fill();
        }
    });
}

function drawExplosions() {
    explosions.forEach(exp => {
        let alpha = exp.timer / 30; // æ·¡å‡º
        ctx.globalAlpha = alpha;
        
        // ä¸­å¿ƒ
        drawExplosionCell(exp.c, exp.r, true);

        // æ‰‹è‡‚
        exp.cells.forEach(cell => {
            drawExplosionCell(cell.c, cell.r, false);
        });

        ctx.globalAlpha = 1.0;
    });
}

function drawExplosionCell(c, r, center) {
    let x = c * TILE_SIZE;
    let y = r * TILE_SIZE;
    
    // èƒŒæ™¯å…‰
    ctx.fillStyle = "#FFEB3B";
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    
    // æ ¸å¿ƒ
    ctx.fillStyle = "#FF5722";
    let margin = 5;
    if (center) margin = 2;
    drawRoundedRect(x + margin, y + margin, TILE_SIZE - margin*2, TILE_SIZE - margin*2, 8, "#FF5722");

    // æ˜Ÿæ˜Ÿè£é£¾
    ctx.fillStyle = "#FFF";
    ctx.beginPath();
    ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 4, 0, Math.PI*2);
    ctx.fill();
}

function drawItems() {
    items.forEach(it => {
        if (it.hidden) return;
        let x = it.x * TILE_SIZE + TILE_SIZE/2;
        let y = it.y * TILE_SIZE + TILE_SIZE/2;

        let icon = '';
        let color = '';
        
        switch(it.type) {
            case 'bomb': icon = 'ğŸ’£'; color = '#EF9A9A'; break;
            case 'fire': icon = 'ğŸ”¥'; color = '#FFCC80'; break;
            case 'speed': icon = 'ğŸ‘Ÿ'; color = '#81D4FA'; break;
            case 'kick': icon = 'ğŸ‘'; color = '#A5D6A7'; break;
        }

        // é“å…·æ¡†
        ctx.fillStyle = color;
        drawRoundedRect(x - 14, y - 14, 28, 28, 6, color);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.strokeRect(x - 14, y - 14, 28, 28);

        // åœ–ç¤º
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#333";
        ctx.fillText(icon, x, y + 2);
    });
}

// --- éŠæˆ²é‚è¼¯ ---

function placeBomb() {
    let pc = toGrid(player.x);
    let pr = toGrid(player.y);

    // æª¢æŸ¥æ•¸é‡é™åˆ¶
    let activeBombs = bombs.filter(b => b.owner === 'player').length;
    if (activeBombs >= player.maxBombs) return;

    // æª¢æŸ¥è©²æ ¼æ˜¯å¦å·²æœ‰ç‚¸å½ˆ
    if (bombs.some(b => b.c === pc && b.r === pr)) return;

    bombs.push({
        r: pr, c: pc,
        timer: 180, // 3 ç§’ (60fps * 3)
        range: player.bombRange,
        owner: 'player',
        slidingX: 0, 
        slidingY: 0
    });
    
    // æ›´æ–°åœ°åœ–æ¨™è¨˜ç‚ºä¸å¯é€šè¡Œï¼ˆå¦‚æœä¸æ˜¯å·²åœ¨è£¡é¢ï¼‰
    // æ³¨æ„ï¼šç‚¸å½ˆå‰›æ”¾ä¸‹æ™‚ç©å®¶é‚„åœ¨è£¡é¢ï¼Œæ‰€ä»¥ä¸èƒ½ç«‹åˆ»è¨­ç‚º WALL_HARD
    // æˆ‘å€‘ä½¿ç”¨å‹•æ…‹ç¢°æ’ï¼šå¦‚æœç©å®¶é‡ç–Šç‚¸å½ˆï¼Œä¸ç¢°æ’ï¼›ä¸€æ—¦é›¢é–‹ï¼Œå‰‡è¦–ç‚ºéšœç¤™
    
    playSound('plant');
}

function explodeBomb(bomb) {
    let centerC = bomb.c;
    let centerR = bomb.r;
    let range = bomb.range;

    // å¾åˆ—è¡¨ç§»é™¤
    bombs = bombs.filter(b => b !== bomb);
    playSound('explode');

    // ç”¢ç”Ÿçˆ†ç‚¸ç‰©ä»¶
    let explosion = {
        c: centerC, r: centerR,
        timer: 30, // æŒçºŒ 0.5 ç§’
        cells: []
    };

    // è¨ˆç®—çˆ†ç‚¸ç¯„åœ (åå­—)
    const dirs = [{dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}];
    
    dirs.forEach(d => {
        for(let i=1; i<=range; i++) {
            let nc = centerC + d.dx * i;
            let nr = centerR + d.dy * i;
            let type = getTile(nc, nr);

            if (type === TYPES.WALL_HARD) break; // é‹¼ç‰†é˜»æ“‹

            explosion.cells.push({c: nc, r: nr});

            if (type === TYPES.WALL_SOFT) {
                // ç‚¸æ¯€è»Ÿç‰†
                setTile(nc, nr, TYPES.FLOOR);
                // ç”¢ç”Ÿç ´ç¢ç‰¹æ•ˆ (ç°¡å–®ç²’å­)
                createParticles(nc * TILE_SIZE + TILE_SIZE/2, nr * TILE_SIZE + TILE_SIZE/2, "#8D6E63");
                
                // é¡¯ç¤ºè©²æ ¼çš„é“å…·æˆ–å‡ºå£
                items.forEach(it => {
                    if (it.x === nc && it.y === nr) it.hidden = false;
                });
                if (exitPos.x === nc && exitPos.y === nr) exitPos.revealed = true;
                
                break; // è»Ÿç‰†é˜»æ“‹å¾ŒçºŒç«å…‰
            }

            // é€£é–å¼•çˆ†å…¶ä»–ç‚¸å½ˆ
            let otherBomb = bombs.find(b => b.c === nc && b.r === nr);
            if (otherBomb) {
                // å»¶é²ä¸€é»é»å¼•çˆ†é¿å…åŒæ™‚è¨ˆç®—å•é¡Œï¼Œæˆ–è€…ç›´æ¥å¼•çˆ†
                // ç°¡å–®èµ·è¦‹ï¼Œç›´æ¥éè¿´ç¸®çŸ­æ™‚é–“
                otherBomb.timer = 1; 
            }
        }
    });
    
    explosions.push(explosion);
}

function createParticles(x, y, color) {
    for(let i=0; i<8; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 30,
            color: color
        });
    }
}

function movePlayer() {
    if (player.dead) return;

    player.dx = 0;
    player.dy = 0;
    let speed = player.speed * player.speedMulti;

    if (keys['ArrowUp']) { player.dy = -speed; player.direction = 'up'; }
    if (keys['ArrowDown']) { player.dy = speed; player.direction = 'down'; }
    if (keys['ArrowLeft']) { player.dx = -speed; player.direction = 'left'; }
    if (keys['ArrowRight']) { player.dx = speed; player.direction = 'right'; }

    // X è»¸ç§»å‹•èˆ‡ç¢°æ’
    if (player.dx !== 0) {
        let newX = player.x + player.dx;
        if (!checkCollision(newX, player.y)) {
            player.x = newX;
        } else {
            // æ»‘å‹•ä¿®æ­£ (Corner sliding)
            let gridY = toGrid(player.y);
            let snapY = gridY * TILE_SIZE + TILE_SIZE/2;
            if (Math.abs(player.y - snapY) < TILE_SIZE/3) {
                if (player.y < snapY) player.y++;
                else player.y--;
            }
        }
    }

    // Y è»¸ç§»å‹•èˆ‡ç¢°æ’
    if (player.dy !== 0) {
        let newY = player.y + player.dy;
        if (!checkCollision(player.x, newY)) {
            player.y = newY;
        } else {
            // æ»‘å‹•ä¿®æ­£
            let gridX = toGrid(player.x);
            let snapX = gridX * TILE_SIZE + TILE_SIZE/2;
            if (Math.abs(player.x - snapX) < TILE_SIZE/3) {
                if (player.x < snapX) player.x++;
                else player.x--;
            }
        }
    }

    // èµ°è·¯å‹•ç•«
    if (player.dx !== 0 || player.dy !== 0) {
        player.walkFrame++;
    } else {
        player.walkFrame = 0;
    }

    // æ’¿é“å…·
    let pc = toGrid(player.x);
    let pr = toGrid(player.y);
    let itemIdx = items.findIndex(it => !it.hidden && it.x === pc && it.y === pr);
    if (itemIdx !== -1) {
        let it = items[itemIdx];
        items.splice(itemIdx, 1);
        playSound('item');
        
        if (it.type === 'bomb') player.maxBombs++;
        if (it.type === 'fire') player.bombRange++;
        if (it.type === 'speed') player.speedMulti = Math.min(player.speedMulti + 0.3, 2.0); // ä¸Šé™
        if (it.type === 'kick') player.hasKick = true;
        
        updateHUD();
        
        // æµ®å‹•æ–‡å­—ç‰¹æ•ˆ
        createParticles(player.x, player.y, "#FFD700");
    }

    // è¸¢ç‚¸å½ˆé‚è¼¯
    if (player.hasKick) {
        bombs.forEach(b => {
            if (b.slidingX === 0 && b.slidingY === 0) {
                // ç°¡å–®åˆ¤å®šï¼šå¦‚æœç©å®¶ä¸­å¿ƒå¾ˆé è¿‘ç‚¸å½ˆä¸­å¿ƒï¼Œä¸”æ­£åœ¨ç§»å‹•
                let dist = Math.hypot(player.x - (b.c * TILE_SIZE + TILE_SIZE/2), player.y - (b.r * TILE_SIZE + TILE_SIZE/2));
                if (dist < TILE_SIZE * 0.8) {
                    if (keys['ArrowRight'] && player.dx > 0 && player.x < (b.c*TILE_SIZE)) b.slidingX = 1;
                    else if (keys['ArrowLeft'] && player.dx < 0 && player.x > (b.c*TILE_SIZE + TILE_SIZE)) b.slidingX = -1;
                    else if (keys['ArrowDown'] && player.dy > 0 && player.y < (b.r*TILE_SIZE)) b.slidingY = 1;
                    else if (keys['ArrowUp'] && player.dy < 0 && player.y > (b.r*TILE_SIZE + TILE_SIZE)) b.slidingY = -1;
                }
            }
        });
    }

    // å‡ºå£åˆ¤å®š
    if (enemies.length === 0 && exitPos.revealed) {
        let dist = Math.hypot(player.x - (exitPos.x * TILE_SIZE + TILE_SIZE/2), player.y - (exitPos.y * TILE_SIZE + TILE_SIZE/2));
        if (dist < 10) {
            gameWin();
        }
    }
}

function checkCollision(x, y) {
    // æª¢æŸ¥å››å€‹è§’
    let r = player.radius - 2; // ç¨å¾®å°ä¸€é»è®“æ‰‹æ„Ÿå¥½ä¸€é»
    let points = [
        {c: toGrid(x-r), r: toGrid(y-r)},
        {c: toGrid(x+r), r: toGrid(y-r)},
        {c: toGrid(x-r), r: toGrid(y+r)},
        {c: toGrid(x+r), r: toGrid(y+r)}
    ];

    // æ–°å¢ï¼šè¨ˆç®—ç•¶å‰ä½ç½®çš„æ ¼å­é»ï¼Œç”¨ä¾†åˆ¤æ–·æ˜¯å¦"å·²ç¶“"åœ¨ç‚¸å½ˆå…§éƒ¨
    let currPoints = [
        {c: toGrid(player.x-r), r: toGrid(player.y-r)},
        {c: toGrid(player.x+r), r: toGrid(player.y-r)},
        {c: toGrid(player.x-r), r: toGrid(player.y+r)},
        {c: toGrid(player.x+r), r: toGrid(player.y+r)}
    ];

    for(let p of points) {
        // ç‰†å£
        if (getTile(p.c, p.r) !== TYPES.FLOOR) return true;
        
        // ç‚¸å½ˆ
        let bomb = bombs.find(b => b.c === p.c && b.r === p.r);
        if (bomb) {
             // ä¿®æ­£åˆ¤å®šï¼šæª¢æŸ¥ç©å®¶ã€Œç›®å‰ã€æ˜¯å¦èˆ‡è©²ç‚¸å½ˆé‡ç–Š
             // å¦‚æœç•¶å‰çš„è§’æœ‰ä»»ä½•ä¸€å€‹åœ¨è©²ç‚¸å½ˆçš„æ ¼å­å…§ï¼Œè¡¨ç¤ºç©å®¶é‚„æ²’èµ°å‡ºå»ï¼Œå…è¨±ç§»å‹•
             let isInside = currPoints.some(cp => cp.c === bomb.c && cp.r === bomb.r);

             if (!isInside) {
                 return true; // å¦‚æœä¸åœ¨è£¡é¢ï¼Œå‰‡è¦–ç‚ºå¯¦é«”ï¼Œç™¼ç”Ÿç¢°æ’
             }
        }
    }
    return false;
}

function updateHUD() {
    hudBomb.textContent = player.maxBombs;
    hudPower.textContent = player.bombRange;
    hudSpeed.textContent = Math.floor(player.speedMulti * 10) / 10;
    hudEnemies.textContent = enemies.length;
}

function gameOver() {
    gameRunning = false;
    player.dead = true;
    playSound('die');
    overlayTitle.textContent = "GAME OVER";
    overlayTitle.style.color = "#D32F2F";
    overlaySub.textContent = "Oh no! The kitty got hurt!";
    startBtn.textContent = "TRY AGAIN";
    overlay.classList.remove('hidden');
}

function gameWin() {
    gameRunning = false;
    playSound('win');
    overlayTitle.textContent = "YOU WIN!";
    overlayTitle.style.color = "#388E3C";
    overlaySub.textContent = "Great job! Area Clear!";
    startBtn.textContent = "PLAY AGAIN";
    overlay.classList.remove('hidden');
}

function gameLoop(timestamp) {
    if (!gameRunning) {
        // å³ä¾¿ä¸è·‘éŠæˆ²é‚è¼¯ï¼Œä¹Ÿè¦ç•«å‡ºä¾†æœ€å¾Œä¸€å¹€
        // draw(); 
        return; 
    }
    
    // --- Update ---
    
    // Player
    movePlayer();

    // Bombs logic
    for (let i = bombs.length - 1; i >= 0; i--) {
        let b = bombs[i];
        
        // æ»‘å‹•é‚è¼¯
        if (b.slidingX !== 0 || b.slidingY !== 0) {
            // æ¯å¹¾å¹€ç§»å‹•ä¸€æ ¼çš„é€Ÿåº¦
            // é€™è£¡ç°¡åŒ–ï¼šæ¯ 5 å¹€ç§»å‹• 1 æ ¼
            if (!b.slideCounter) b.slideCounter = 0;
            b.slideCounter++;
            if (b.slideCounter > 4) {
                let nc = b.c + b.slidingX;
                let nr = b.r + b.slidingY;
                let nextTile = getTile(nc, nr);
                // æª¢æŸ¥æ˜¯å¦æœ‰éšœç¤™ç‰©æˆ–ç‚¸å½ˆæˆ–æ•µäºº
                let hasBomb = bombs.some(obs => obs.c === nc && obs.r === nr);
                let hasEnemy = enemies.some(e => e.c === nc && e.r === nr); // æ’åˆ°æ•µäººåœæ­¢
                
                if (nextTile === TYPES.FLOOR && !hasBomb && !hasEnemy) {
                    b.c = nc;
                    b.r = nr;
                } else {
                    b.slidingX = 0;
                    b.slidingY = 0;
                }
                b.slideCounter = 0;
            }
        }

        b.timer--;
        if (b.timer <= 0) {
            explodeBomb(b);
        }
    }

    // Explosions logic
    for (let i = explosions.length - 1; i >= 0; i--) {
        let ex = explosions[i];
        ex.timer--;
        if (ex.timer <= 0) {
            explosions.splice(i, 1);
            continue;
        }

        // æª¢æŸ¥å‚·å®³åˆ¤å®š (ç©å®¶)
        // ä¸­å¿ƒ
        if (toGrid(player.x) === ex.c && toGrid(player.y) === ex.r) gameOver();
        // æ‰‹è‡‚
        ex.cells.forEach(cell => {
            if (toGrid(player.x) === cell.c && toGrid(player.y) === cell.r) gameOver();
        });
    }

    // Enemies Logic
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        
        // ç§»å‹•
        let dirs = [[0,-1], [0,1], [-1,0], [1,0]]; // up, down, left, right
        let move = dirs[e.dir];
        let newX = e.x + move[0] * e.speed;
        let newY = e.y + move[1] * e.speed;
        
        // ç°¡å–®ç¢°æ’ (é‡å°ä¸­å¿ƒé»)
        let cr = toGrid(newY);
        let cc = toGrid(newX);
        
        // æ’ç‰†æˆ–æ’ç‚¸å½ˆæ›æ–¹å‘
        let tile = getTile(cc, cr);
        let hitBomb = bombs.some(b => b.c === cc && b.r === cr);
        
        if (tile !== TYPES.FLOOR || hitBomb) {
            // éš¨æ©Ÿæ›æ–¹å‘
            e.dir = Math.floor(Math.random() * 4);
        } else {
            // ä¸­å¿ƒé»å°é½Šä¿®æ­£ (é¿å…å¡ç‰†è§’)
            if (e.dir < 2) { // å‚ç›´ç§»å‹•ï¼Œä¿®æ­£ X
                e.x = snapCenter(e.x);
                e.y = newY;
            } else { // æ°´å¹³ç§»å‹•ï¼Œä¿®æ­£ Y
                e.x = newX;
                e.y = snapCenter(e.y);
            }
            // æ›´æ–° Grid åº§æ¨™
            e.c = toGrid(e.x);
            e.r = toGrid(e.y);
        }

        // ç¢°ç©å®¶
        let dist = Math.hypot(e.x - player.x, e.y - player.y);
        if (dist < TILE_SIZE * 0.8) {
            gameOver();
        }

        // ç¢°çˆ†ç‚¸
        let hitExplosion = false;
        explosions.forEach(ex => {
            if ((ex.c === e.c && ex.r === e.r) || 
                ex.cells.some(cell => cell.c === e.c && cell.r === e.r)) {
                hitExplosion = true;
            }
        });

        if (hitExplosion) {
            enemies.splice(i, 1);
            createParticles(e.x, e.y, "#9C27B0");
            updateHUD();
        }
    }

    // Particles logic
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if(p.life <= 0) particles.splice(i, 1);
    }

    // --- Draw ---
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    
    drawMap();
    drawItems();
    drawBombs();
    
    // æ•µäºº
    enemies.forEach(e => drawEnemy(e));

    // ç©å®¶ (å¦‚æœåœ¨ç„¡æ•µé–ƒçˆç‹€æ…‹å¯åŠ  alpha)
    if (!player.dead) drawCat(player.x, player.y, player.direction, player.walkFrame);

    drawExplosions();

    // ç²’å­
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
        ctx.fill();
    });
    ctx.globalAlpha = 1.0;

    if (gameRunning) requestAnimationFrame(gameLoop);
}

// --- å•Ÿå‹• ---
startBtn.addEventListener('click', () => {
    // å¿…é ˆç”±ä½¿ç”¨è€…äº’å‹•è§¸ç™¼ AudioContext
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    resetGame();
});

// åˆå§‹ç•«é¢ç¹ªè£½ä¸€æ¬¡
initMap();
drawMap();

</script>
</body>
</html>
