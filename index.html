<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯æ„›è²“å’ªç‚¸å½ˆè¶…äºº 3D | Cat Bomber 3D</title>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Varela+Round&display=swap');

        :root {
            --bg-color: #FFF3E0;
            --ui-bg: #FFCCBC;
            --text-color: #5D4037;
            --accent: #FF7043;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Varela Round', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        h1 {
            position: absolute;
            top: 10px;
            z-index: 5;
            font-family: 'Fredoka One', cursive;
            color: var(--accent);
            text-shadow: 2px 2px 0px #FFF, 4px 4px 0px rgba(0,0,0,0.1);
            margin: 0;
            font-size: 2.5rem;
            pointer-events: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #87CEEB; /* å¤©ç©ºè—èƒŒæ™¯ */
        }

        #ui-layer {
            position: absolute;
            top: 60px; /* æ¨™é¡Œä¸‹æ–¹ */
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            height: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 25px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            font-weight: bold;
            font-size: 1.2rem;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 243, 224, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        .hidden {
            display: none !important;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Fredoka One', cursive;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 0 #E64A19;
            transition: transform 0.1s, box-shadow 0.1s;
            margin-top: 20px;
            pointer-events: auto;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 1px 0 #E64A19;
        }

        button:hover {
            filter: brightness(1.1);
        }

        .msg-title {
            font-family: 'Fredoka One', cursive;
            font-size: 3rem;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .msg-sub {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .instructions {
            margin-top: 30px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: left;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }
        
        .key {
            display: inline-block;
            background: #eee;
            padding: 2px 6px;
            border-radius: 4px;
            border-bottom: 2px solid #ccc;
            font-size: 0.9em;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <h1>ğŸ± Cat Bomber 3D</h1>

    <div id="game-container">
        <div id="ui-layer">
            <div class="hud-item">
                <span>ğŸ’£</span> <span id="hud-bomb">1</span>
            </div>
            <div class="hud-item">
                <span>ğŸ”¥</span> <span id="hud-power">1</span>
            </div>
            <div class="hud-item">
                <span>ğŸ‘Ÿ</span> <span id="hud-speed">1</span>
            </div>
            <div class="hud-item" style="color: #E57373;">
                <span>ğŸ‘¾</span> <span id="hud-enemies">0</span>
            </div>
        </div>
        
        <!-- Three.js Canvas æœƒè‡ªå‹•æ’å…¥é€™è£¡ -->

        <div id="overlay">
            <div class="msg-title" id="overlay-title">Cat Bomber 3D</div>
            <div class="msg-sub" id="overlay-sub">Help the kitty find the exit!</div>
            <button id="start-btn">START GAME</button>
            
            <div class="instructions">
                <p><span class="key">â†‘</span> <span class="key">â†“</span> <span class="key">â†</span> <span class="key">â†’</span> ç§»å‹• Move</p>
                <p><span class="key">SPACE</span> æ”¾ç‚¸å½ˆ Bomb</p>
                <p>ç›®æ¨™ï¼šæ‰“æ•—æ‰€æœ‰æ•µäººä¸¦æ‰¾åˆ°å‡ºå£é–€ ğŸšª</p>
            </div>
        </div>
    </div>

<script>
/**
 * Cat Bomber 3D Game Logic & Rendering
 */

// --- éŠæˆ²é‚è¼¯å¸¸æ•¸ (Logic) ---
const TILE_SIZE = 40; // é‚è¼¯ä¸Šçš„åƒç´ å–®ä½ï¼Œæˆ‘å€‘æœƒé™¤ä»¥å®ƒä¾†è½‰æˆ 3D å–®ä½
const COLS = 13;
const ROWS = 11;

// --- 3D æ¸²æŸ“å¸¸æ•¸ (Rendering) ---
const UNIT_SIZE = 4; // 3D ä¸–ç•Œä¸­ä¸€å€‹æ ¼å­çš„å¤§å°
const MAP_OFFSET_X = -(COLS * UNIT_SIZE) / 2;
const MAP_OFFSET_Z = -(ROWS * UNIT_SIZE) / 2;

// --- å¯¦é«”é¡å‹ ---
const TYPES = {
    FLOOR: 0,
    WALL_HARD: 1,
    WALL_SOFT: 2,
    BOMB: 3,
    EXIT: 9,
};

// --- UI å…ƒç´  ---
const hudBomb = document.getElementById('hud-bomb');
const hudPower = document.getElementById('hud-power');
const hudSpeed = document.getElementById('hud-speed');
const hudEnemies = document.getElementById('hud-enemies');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlay-title');
const overlaySub = document.getElementById('overlay-sub');
const startBtn = document.getElementById('start-btn');
const gameContainer = document.getElementById('game-container');

// --- éŸ³æ•ˆç³»çµ± (Web Audio API) ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = new AudioCtx();

const playSound = (type) => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === 'plant') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'explode') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'item') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.setValueAtTime(1200, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'win') {
        osc.type = 'triangle';
        gainNode.gain.value = 0.3;
        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.connect(g);
            g.connect(audioCtx.destination);
            o.frequency.value = freq;
            g.gain.setValueAtTime(0.2, now + i*0.1);
            g.gain.exponentialRampToValueAtTime(0.01, now + i*0.1 + 0.3);
            o.start(now + i*0.1);
            o.stop(now + i*0.1 + 0.3);
        });
    } else if (type === 'die') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.5);
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.linearRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
    }
};

// --- Three.js Setup ---
let scene, camera, renderer;
let meshes = {
    walls: [], // 2D array [r][c] -> mesh
    player: null,
    enemies: new Map(), // id -> mesh
    bombs: new Map(),   // id -> mesh
    items: new Map(),   // id -> mesh
    explosions: [],     // array of mesh groups
    particles: []       // array of particle objects
};

function initThree() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // å¤©ç©ºè—
    // éœ§æ°£æ•ˆæœï¼Œè®“é‚Šç·£æŸ”å’Œ
    scene.fog = new THREE.Fog(0x87CEEB, 40, 90);

    // ç›¸æ©Ÿ (Perspective)
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 45, 35); // é«˜è§’åº¦ä¿¯è¦–
    camera.lookAt(0, 0, 5);

    // ç‡ˆå…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(20, 40, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.left = -40;
    dirLight.shadow.camera.right = 40;
    dirLight.shadow.camera.top = 40;
    dirLight.shadow.camera.bottom = -40;
    scene.add(dirLight);

    // æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    gameContainer.appendChild(renderer.domElement);

    // å»ºç«‹åœ°æ¿
    createFloor();
    
    // ç›£è½è¦–çª—èª¿æ•´
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function createFloor() {
    // ä¸»åœ°æ¿å¹³é¢
    const geometry = new THREE.PlaneGeometry(COLS * UNIT_SIZE, ROWS * UNIT_SIZE);
    const material = new THREE.MeshStandardMaterial({ color: 0xFBE9E7 });
    const floor = new THREE.Mesh(geometry, material);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set(0, 0, 0); // ä¸­å¿ƒé»
    floor.receiveShadow = true;
    scene.add(floor);

    // æ ¼ç·š (å¯é¸ï¼Œç”¨ä¾†å¢åŠ ç«‹é«”æ„Ÿ)
    const gridHelper = new THREE.GridHelper(COLS * UNIT_SIZE, Math.max(COLS, ROWS), 0xF6D6D6, 0xF6D6D6);
    gridHelper.position.y = 0.05;
    scene.add(gridHelper);
    
    // åº•éƒ¨è£é£¾åº§ (è®“åœ°åœ–çœ‹èµ·ä¾†åƒæ‡¸æµ®å³¶)
    const baseGeo = new THREE.BoxGeometry(COLS * UNIT_SIZE + 2, 5, ROWS * UNIT_SIZE + 2);
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x8D6E63 });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = -2.55;
    base.receiveShadow = true;
    scene.add(base);
}

// å»ºç«‹æè³ª
const matWallHard = new THREE.MeshStandardMaterial({ color: 0xB0BEC5 });
const matWallSoft = new THREE.MeshStandardMaterial({ color: 0xA1887F });
const matPlayer = new THREE.MeshStandardMaterial({ color: 0xFFAB91 }); // è²“èº«
const matPlayerFace = new THREE.MeshStandardMaterial({ color: 0xFFCCBC }); // è‚šå­
const matBomb = new THREE.MeshStandardMaterial({ color: 0x212121, roughness: 0.2 });
const matExplosionCore = new THREE.MeshBasicMaterial({ color: 0xFF5722 });
const matExplosionOuter = new THREE.MeshBasicMaterial({ color: 0xFFEB3B, transparent: true, opacity: 0.8 });

// --- è¼”åŠ©ï¼šåº§æ¨™è½‰æ› ---
function logicToWorld(lx, ly) {
    // é‚è¼¯åº§æ¨™ (pixel) -> 3D ä¸–ç•Œåº§æ¨™
    const wx = (lx / TILE_SIZE) * UNIT_SIZE + MAP_OFFSET_X + UNIT_SIZE / 2;
    const wz = (ly / TILE_SIZE) * UNIT_SIZE + MAP_OFFSET_Z + UNIT_SIZE / 2;
    return { x: wx, z: wz };
}

// --- 3D ç‰©ä»¶å»ºç«‹å‡½å¼ ---

function createWallMesh(r, c, type) {
    const geo = new THREE.BoxGeometry(UNIT_SIZE - 0.2, UNIT_SIZE, UNIT_SIZE - 0.2);
    const mat = type === TYPES.WALL_HARD ? matWallHard : matWallSoft;
    const mesh = new THREE.Mesh(geo, mat);
    
    const wPos = logicToWorld(c * TILE_SIZE, r * TILE_SIZE);
    mesh.position.set(wPos.x, UNIT_SIZE / 2, wPos.z);
    
    if (type === TYPES.WALL_HARD) {
        // ç¡¬ç‰†è£é£¾
        const innerGeo = new THREE.BoxGeometry(UNIT_SIZE - 1, UNIT_SIZE + 0.1, UNIT_SIZE - 1);
        const innerMat = new THREE.MeshStandardMaterial({color: 0xCFD8DC});
        const inner = new THREE.Mesh(innerGeo, innerMat);
        mesh.add(inner);
    } else {
        // è»Ÿç‰†è£é£¾ (ç£šç´‹)
        // ç°¡å–®ç”¨é¡è‰²å€åˆ†å³å¯
    }

    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    return mesh;
}

function createPlayerMesh() {
    const group = new THREE.Group();
    
    // èº«é«”
    const bodyGeo = new THREE.CylinderGeometry(1.2, 1.4, 2, 16);
    const body = new THREE.Mesh(bodyGeo, matPlayer);
    body.position.y = 1;
    body.castShadow = true;
    group.add(body);

    // è‚šå­
    const bellyGeo = new THREE.SphereGeometry(1.1, 16, 16);
    const belly = new THREE.Mesh(bellyGeo, matPlayerFace);
    belly.position.set(0, 0.8, 0.5);
    belly.scale.set(0.8, 1, 0.5);
    group.add(belly);

    // é ­
    const headGeo = new THREE.SphereGeometry(1.6, 16, 16);
    const head = new THREE.Mesh(headGeo, matPlayer);
    head.position.y = 2.5;
    head.castShadow = true;
    group.add(head);

    // è€³æœµ
    const earGeo = new THREE.ConeGeometry(0.5, 1, 4);
    const earL = new THREE.Mesh(earGeo, matPlayer);
    earL.position.set(-0.8, 3.5, 0);
    earL.rotation.z = 0.3;
    const earR = new THREE.Mesh(earGeo, matPlayer);
    earR.position.set(0.8, 3.5, 0);
    earR.rotation.z = -0.3;
    group.add(earL);
    group.add(earR);

    // è‡‰ (çœ¼ç›)
    const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
    const matEye = new THREE.MeshBasicMaterial({color: 0x3E2723});
    const eyeL = new THREE.Mesh(eyeGeo, matEye);
    eyeL.position.set(-0.5, 2.5, 1.4);
    const eyeR = new THREE.Mesh(eyeGeo, matEye);
    eyeR.position.set(0.5, 2.5, 1.4);
    group.add(eyeL);
    group.add(eyeR);

    // é¼»å­
    const nose = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({color: 0xD81B60}));
    nose.position.set(0, 2.3, 1.5);
    group.add(nose);

    scene.add(group);
    return group;
}

function createEnemyMesh(type) {
    const group = new THREE.Group();
    
    if (type === 'slime') {
        const geo = new THREE.SphereGeometry(1.4, 16, 12, 0, Math.PI * 2, 0, Math.PI * 0.6); // åŠåœ“çƒ
        const mat = new THREE.MeshStandardMaterial({color: 0x42A5F5, roughness: 0.1});
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = 0; // æœä¸Š
        mesh.position.y = 0;
        mesh.scale.y = 0.8;
        group.add(mesh);

        // çœ¼ç›
        const eyeGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const matWhite = new THREE.MeshBasicMaterial({color: 0xFFFFFF});
        const eyeL = new THREE.Mesh(eyeGeo, matWhite);
        eyeL.position.set(-0.5, 0.8, 1);
        const eyeR = new THREE.Mesh(eyeGeo, matWhite);
        eyeR.position.set(0.5, 0.8, 1);
        group.add(eyeL);
        group.add(eyeR);
        
        const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.1, 4, 4), new THREE.MeshBasicMaterial({color: 0x000000}));
        const pL = pupil.clone(); pL.position.set(-0.5, 0.8, 1.25);
        const pR = pupil.clone(); pR.position.set(0.5, 0.8, 1.25);
        group.add(pL);
        group.add(pR);

    } else { // chicken
        const body = new THREE.Mesh(new THREE.SphereGeometry(1.3, 16, 16), new THREE.MeshStandardMaterial({color: 0xFFEE58}));
        body.position.y = 1.3;
        group.add(body);
        
        // å˜´å·´
        const beak = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.6, 4), new THREE.MeshStandardMaterial({color: 0xFF7043}));
        beak.rotation.x = Math.PI/2;
        beak.position.set(0, 1.3, 1.3);
        group.add(beak);
        
        // é›å† 
        const comb = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshStandardMaterial({color: 0xEF5350}));
        comb.position.set(0, 2.5, 0);
        group.add(comb);
    }
    
    group.castShadow = true;
    scene.add(group);
    return group;
}

function createBombMesh() {
    const group = new THREE.Group();
    const ball = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16, 16), matBomb);
    ball.position.y = 1.2;
    ball.castShadow = true;
    group.add(ball);

    // è“‹å­
    const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.4, 8), new THREE.MeshStandardMaterial({color: 0x616161}));
    cap.position.y = 2.4;
    group.add(cap);
    
    // å°ç«ç·š
    const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4), new THREE.MeshStandardMaterial({color: 0xFFAB00}));
    fuse.position.y = 2.8;
    group.add(fuse);
    
    scene.add(group);
    return group;
}

function createItemMesh(type) {
    const group = new THREE.Group();
    const box = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({color: 0xFFFFFF, transparent: true, opacity: 0.3}));
    box.position.y = 1;
    group.add(box);
    
    // å…§æ ¸ icon
    let color = 0xFFFFFF;
    if (type === 'bomb') color = 0xEF9A9A;
    if (type === 'fire') color = 0xFFCC80;
    if (type === 'speed') color = 0x81D4FA;
    if (type === 'kick') color = 0xA5D6A7;
    
    const core = new THREE.Mesh(new THREE.OctahedronGeometry(0.8), new THREE.MeshStandardMaterial({color: color, emissive: color, emissiveIntensity: 0.5}));
    core.position.y = 1;
    // æ—‹è½‰å‹•ç•«åœ¨ loop ä¸­åš
    core.userData = { isCore: true };
    group.add(core);

    scene.add(group);
    return group;
}

function createExitMesh(r, c) {
    const group = new THREE.Group();
    const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 0.5), new THREE.MeshStandardMaterial({color: 0x333333}));
    doorFrame.position.y = 1.5;
    doorFrame.position.z = -1; // ç¨å¾®å¾Œé€€
    group.add(doorFrame);
    
    const doorLight = new THREE.Mesh(new THREE.PlaneGeometry(2, 2.5), new THREE.MeshBasicMaterial({color: 0x4FC3F7}));
    doorLight.position.y = 1.5;
    doorLight.position.z = -0.7;
    group.add(doorLight);
    
    const wPos = logicToWorld(c * TILE_SIZE, r * TILE_SIZE);
    group.position.set(wPos.x, 0, wPos.z);
    
    scene.add(group);
    return group;
}

function createExplosionEffect(c, r, center) {
    const group = new THREE.Group();
    const wPos = logicToWorld(c * TILE_SIZE, r * TILE_SIZE);
    group.position.set(wPos.x, 2, wPos.z);

    const core = new THREE.Mesh(new THREE.BoxGeometry(3.5, 3.5, 3.5), matExplosionCore);
    group.add(core);
    
    const outer = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), matExplosionOuter);
    group.add(outer);

    scene.add(group);
    meshes.explosions.push({ mesh: group, life: 30, maxLife: 30 });
}

// --- éŠæˆ²é‚è¼¯èˆ‡ç‹€æ…‹ (Logic System) ---
// (é€™éƒ¨åˆ†å¾åŸæœ¬çš„ä»£ç¢¼ç§»æ¤ï¼Œåªåšå¿…è¦ä¿®æ”¹)

let gameRunning = false;
let map = [];
let bombs = [];
let items = [];
let enemies = [];
let exitPos = {x: 0, y: 0, revealed: false, mesh: null};

// ç©å®¶é‚è¼¯ç‰©ä»¶
const player = {
    x: TILE_SIZE,
    y: TILE_SIZE,
    radius: TILE_SIZE * 0.4,
    speed: 2,
    dx: 0, dy: 0,
    maxBombs: 1,
    bombRange: 1,
    hasKick: false,
    speedMulti: 1,
    direction: 'down',
    dead: false,
    id: 'p1'
};

const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Space' && gameRunning && !player.dead) {
        placeBomb();
    }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// 3D å°ˆç”¨ï¼šç”Ÿæˆ ID
let _idCounter = 0;
function getUniqueId() { return _idCounter++; }

function initMap() {
    map = [];
    meshes.walls = []; // é‡ç½®ç‰†å£ç¶²æ ¼é™£åˆ—
    let softBlocks = [];

    // æ¸…ç©ºå ´æ™¯ä¸­ç¾æœ‰çš„ç‰†
    // é€™è£¡æˆ‘å€‘ç›´æ¥ç°¡å–®ç²—æš´åœ°é‡å»º
    // (åœ¨ resetGame è™•ç†å ´æ™¯æ¸…ç†)

    for (let r = 0; r < ROWS; r++) {
        const row = [];
        const meshRow = [];
        for (let c = 0; c < COLS; c++) {
            let type = TYPES.FLOOR;
            if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) type = TYPES.WALL_HARD;
            else if (r % 2 === 0 && c % 2 === 0) type = TYPES.WALL_HARD;
            else if ((r === 1 && c === 1) || (r === 1 && c === 2) || (r === 2 && c === 1)) type = TYPES.FLOOR;
            else if (Math.random() < 0.4) {
                type = TYPES.WALL_SOFT;
                softBlocks.push({r, c});
            }
            
            row.push(type);
            
            // å»ºç«‹å°æ‡‰çš„ 3D ç‰†
            if (type !== TYPES.FLOOR) {
                meshRow.push(createWallMesh(r, c, type));
            } else {
                meshRow.push(null);
            }
        }
        map.push(row);
        meshes.walls.push(meshRow);
    }

    // å‡ºå£
    if (softBlocks.length > 0) {
        const exitIdx = Math.floor(Math.random() * softBlocks.length);
        exitPos = { x: softBlocks[exitIdx].c, y: softBlocks[exitIdx].r, revealed: false, mesh: null };
        softBlocks.splice(exitIdx, 1);
    } else {
        exitPos = { x: COLS-2, y: ROWS-2, revealed: false, mesh: null };
    }

    // é“å…·
    const itemsToSpawn = [{type: 'bomb', count: 3}, {type: 'fire', count: 3}, {type: 'speed', count: 2}, {type: 'kick', count: 1}];
    items = [];
    itemsToSpawn.forEach(it => {
        for(let i=0; i<it.count; i++) {
            if (softBlocks.length > 0) {
                const idx = Math.floor(Math.random() * softBlocks.length);
                const pos = softBlocks[idx];
                items.push({
                    id: getUniqueId(),
                    x: pos.c, y: pos.r, 
                    type: it.type, 
                    hidden: true
                });
                softBlocks.splice(idx, 1);
            }
        }
    });

    // æ•µäºº
    enemies = [];
    let enemyCount = 3 + Math.floor(Math.random() * 2);
    while(enemies.length < enemyCount) {
        let er = Math.floor(Math.random() * ROWS);
        let ec = Math.floor(Math.random() * COLS);
        if (map[er][ec] === TYPES.FLOOR && (er + ec > 3)) {
            enemies.push({
                id: getUniqueId(),
                x: ec * TILE_SIZE + TILE_SIZE/2,
                y: er * TILE_SIZE + TILE_SIZE/2,
                r: er, c: ec,
                dir: Math.floor(Math.random()*4),
                speed: 1 + Math.random() * 0.5,
                type: Math.random() > 0.5 ? 'slime' : 'chicken'
            });
        }
    }
}

function clearScene() {
    // ç§»é™¤æ‰€æœ‰å‹•æ…‹ç‰©ä»¶
    meshes.enemies.forEach(m => scene.remove(m));
    meshes.enemies.clear();
    meshes.bombs.forEach(m => scene.remove(m));
    meshes.bombs.clear();
    meshes.items.forEach(m => scene.remove(m));
    meshes.items.clear();
    meshes.explosions.forEach(o => scene.remove(o.mesh));
    meshes.explosions = [];
    
    // ç§»é™¤ç‰†å£
    if(meshes.walls.length > 0) {
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(meshes.walls[r][c]) {
                    scene.remove(meshes.walls[r][c]);
                }
            }
        }
    }
    
    if (meshes.player) {
        scene.remove(meshes.player);
        meshes.player = null;
    }
    
    if (exitPos.mesh) {
        scene.remove(exitPos.mesh);
        exitPos.mesh = null;
    }
}

function resetGame() {
    clearScene();
    
    bombs = [];
    items = [];
    
    // é‡ç½®ç©å®¶
    player.x = TILE_SIZE * 1.5;
    player.y = TILE_SIZE * 1.5;
    player.maxBombs = 1;
    player.bombRange = 1;
    player.speedMulti = 1;
    player.hasKick = false;
    player.dead = false;

    // å»ºç«‹ 3D å¯¦é«”
    initMap();
    meshes.player = createPlayerMesh();

    // --- é—œéµä¿®æ­£ï¼šé‡ç½®æ”å½±æ©Ÿä½ç½®ç‚ºæœ€ä½³éŠç©è¦–è§’ ---
    // èª¿æ•´ç‚ºæ›´é«˜çš„ä¿¯è¦–è§’ (Y=70, Z=10)
    // é€™æ¨£æ¥è¿‘å‚ç›´ä¿¯è¦–ï¼Œè¦–é‡æ›´é–‹é—Š
    camera.position.set(0, 70, 10);
    camera.lookAt(0, -2, 0); 
    
    updateHUD();
    gameRunning = true;
    overlay.classList.add('hidden');
    
    // é–‹å§‹ Loop
    if (!renderer.info.autoClear) animate(); // hack check if running
}

// --- é‚è¼¯è¼”åŠ© ---
function getTile(col, row) {
    if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return TYPES.WALL_HARD;
    return map[row][col];
}
function setTile(col, row, type) {
    if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
        map[row][col] = type;
        // 3D åŒæ­¥ï¼šç§»é™¤ç‰†å£ Mesh
        if (type === TYPES.FLOOR && meshes.walls[row][col]) {
            scene.remove(meshes.walls[row][col]);
            meshes.walls[row][col] = null;
            
            // ç²’å­ç‰¹æ•ˆ
            createDebris(col, row);
        }
    }
}
function createDebris(c, r) {
    // ç°¡å–®çš„æ–¹å¡Šç²’å­
    const wPos = logicToWorld(c * TILE_SIZE, r * TILE_SIZE);
    for(let i=0; i<5; i++) {
        const geo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const mat = new THREE.MeshBasicMaterial({color: 0x8D6E63});
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(wPos.x, 1, wPos.z);
        
        const velocity = {
            x: (Math.random() - 0.5) * 0.5,
            y: Math.random() * 0.5,
            z: (Math.random() - 0.5) * 0.5
        };
        scene.add(mesh);
        meshes.particles.push({mesh, velocity, life: 60});
    }
}

function toGrid(px) { return Math.floor(px / TILE_SIZE); }
function snapCenter(val) { return Math.floor(val / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2; }

function checkCollision(x, y) {
    let r = player.radius - 2;
    let points = [
        {c: toGrid(x-r), r: toGrid(y-r)},
        {c: toGrid(x+r), r: toGrid(y-r)},
        {c: toGrid(x-r), r: toGrid(y+r)},
        {c: toGrid(x+r), r: toGrid(y+r)}
    ];
    let currPoints = [
        {c: toGrid(player.x-r), r: toGrid(player.y-r)},
        {c: toGrid(player.x+r), r: toGrid(player.y-r)},
        {c: toGrid(player.x-r), r: toGrid(player.y+r)},
        {c: toGrid(player.x+r), r: toGrid(player.y+r)}
    ];

    for(let p of points) {
        if (getTile(p.c, p.r) !== TYPES.FLOOR) return true;
        let bomb = bombs.find(b => b.c === p.c && b.r === p.r);
        if (bomb) {
             let isInside = currPoints.some(cp => cp.c === bomb.c && cp.r === bomb.r);
             if (!isInside) return true;
        }
    }
    return false;
}

function placeBomb() {
    let pc = toGrid(player.x);
    let pr = toGrid(player.y);
    let activeBombs = bombs.filter(b => b.owner === 'player').length;
    if (activeBombs >= player.maxBombs) return;
    if (bombs.some(b => b.c === pc && b.r === pr)) return;

    const id = getUniqueId();
    bombs.push({
        id: id,
        r: pr, c: pc,
        timer: 180,
        range: player.bombRange,
        owner: 'player',
        slidingX: 0, slidingY: 0
    });
    
    // 3D å»ºç«‹ç‚¸å½ˆ
    const mesh = createBombMesh();
    const wPos = logicToWorld(pc * TILE_SIZE, pr * TILE_SIZE);
    mesh.position.set(wPos.x, 0, wPos.z);
    meshes.bombs.set(id, mesh);

    playSound('plant');
}

function explodeBomb(bomb) {
    let centerC = bomb.c;
    let centerR = bomb.r;
    let range = bomb.range;

    bombs = bombs.filter(b => b !== bomb);
    // 3D ç§»é™¤ç‚¸å½ˆ
    if (meshes.bombs.has(bomb.id)) {
        scene.remove(meshes.bombs.get(bomb.id));
        meshes.bombs.delete(bomb.id);
    }
    playSound('explode');

    // çˆ†ç‚¸ç‰¹æ•ˆ
    createExplosionEffect(centerC, centerR, true);

    const dirs = [{dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}];
    
    dirs.forEach(d => {
        for(let i=1; i<=range; i++) {
            let nc = centerC + d.dx * i;
            let nr = centerR + d.dy * i;
            let type = getTile(nc, nr);

            if (type === TYPES.WALL_HARD) break;

            // ç”¢ç”Ÿçˆ†ç‚¸è¦–è¦º
            createExplosionEffect(nc, nr, false);

            // æª¢æŸ¥å‚·å®³åˆ¤å®š (ç©å®¶)
            if (toGrid(player.x) === nc && toGrid(player.y) === nr) gameOver();
            // æª¢æŸ¥ä¸­å¿ƒé»å‚·å®³
            if (toGrid(player.x) === centerC && toGrid(player.y) === centerR) gameOver();

            if (type === TYPES.WALL_SOFT) {
                setTile(nc, nr, TYPES.FLOOR);
                // æª¢æŸ¥é“å…·é¡¯ç¤º
                items.forEach(it => {
                    if (it.x === nc && it.y === nr) it.hidden = false;
                });
                if (exitPos.x === nc && exitPos.y === nr) exitPos.revealed = true;
                break;
            }

            let otherBomb = bombs.find(b => b.c === nc && b.r === nr);
            if (otherBomb) otherBomb.timer = 1;
        }
    });
}

function updateHUD() {
    hudBomb.textContent = player.maxBombs;
    hudPower.textContent = player.bombRange;
    hudSpeed.textContent = Math.floor(player.speedMulti * 10) / 10;
    hudEnemies.textContent = enemies.length;
}

function gameOver() {
    gameRunning = false;
    player.dead = true;
    
    // 3D ç©å®¶å€’ä¸‹
    if (meshes.player) {
        meshes.player.rotation.z = Math.PI / 2;
        meshes.player.position.y = 0.5;
    }
    
    playSound('die');
    overlayTitle.textContent = "GAME OVER";
    overlayTitle.style.color = "#D32F2F";
    overlaySub.textContent = "Oh no! The kitty got hurt!";
    startBtn.textContent = "TRY AGAIN";
    overlay.classList.remove('hidden');
}

function gameWin() {
    gameRunning = false;
    playSound('win');
    overlayTitle.textContent = "YOU WIN!";
    overlayTitle.style.color = "#388E3C";
    overlaySub.textContent = "Great job! Area Clear!";
    startBtn.textContent = "PLAY AGAIN";
    overlay.classList.remove('hidden');
}

// --- ä¸»è¦éŠæˆ²è¿´åœˆ ---

function animate() {
    requestAnimationFrame(animate);

    if (gameRunning && !player.dead) {
        // --- ç©å®¶ç§»å‹• ---
        player.dx = 0; player.dy = 0;
        let speed = player.speed * player.speedMulti;
        if (keys['ArrowUp']) { player.dy = -speed; player.direction = 'up'; }
        if (keys['ArrowDown']) { player.dy = speed; player.direction = 'down'; }
        if (keys['ArrowLeft']) { player.dx = -speed; player.direction = 'left'; }
        if (keys['ArrowRight']) { player.dx = speed; player.direction = 'right'; }

        if (player.dx !== 0) {
            let newX = player.x + player.dx;
            if (!checkCollision(newX, player.y)) player.x = newX;
            else {
                let gridY = toGrid(player.y);
                let snapY = gridY * TILE_SIZE + TILE_SIZE/2;
                if (Math.abs(player.y - snapY) < TILE_SIZE/3) {
                    if (player.y < snapY) player.y++; else player.y--;
                }
            }
        }
        if (player.dy !== 0) {
            let newY = player.y + player.dy;
            if (!checkCollision(player.x, newY)) player.y = newY;
            else {
                let gridX = toGrid(player.x);
                let snapX = gridX * TILE_SIZE + TILE_SIZE/2;
                if (Math.abs(player.x - snapX) < TILE_SIZE/3) {
                    if (player.x < snapX) player.x++; else player.x--;
                }
            }
        }

        // 3D åŒæ­¥ç©å®¶ä½ç½®
        if (meshes.player) {
            const wPos = logicToWorld(player.x, player.y);
            meshes.player.position.x = wPos.x;
            meshes.player.position.z = wPos.z;
            
            // è½‰å‘
            if (player.direction === 'up') meshes.player.rotation.y = Math.PI;
            if (player.direction === 'down') meshes.player.rotation.y = 0;
            if (player.direction === 'left') meshes.player.rotation.y = -Math.PI/2;
            if (player.direction === 'right') meshes.player.rotation.y = Math.PI/2;
            
            // èµ°è·¯å‹•ç•« (Bobbing)
            if (player.dx !== 0 || player.dy !== 0) {
                meshes.player.position.y = Math.sin(Date.now() / 100) * 0.2;
            } else {
                meshes.player.position.y = 0;
            }
        }

        // --- æ’¿é“å…· ---
        let pc = toGrid(player.x);
        let pr = toGrid(player.y);
        let itemIdx = items.findIndex(it => !it.hidden && it.x === pc && it.y === pr);
        if (itemIdx !== -1) {
            let it = items[itemIdx];
            items.splice(itemIdx, 1);
            
            // 3D ç§»é™¤
            if (meshes.items.has(it.id)) {
                scene.remove(meshes.items.get(it.id));
                meshes.items.delete(it.id);
            }
            playSound('item');
            
            if (it.type === 'bomb') player.maxBombs++;
            if (it.type === 'fire') player.bombRange++;
            if (it.type === 'speed') player.speedMulti = Math.min(player.speedMulti + 0.3, 2.0);
            if (it.type === 'kick') player.hasKick = true;
            updateHUD();
        }

        // --- è¸¢ç‚¸å½ˆ ---
        if (player.hasKick) {
            bombs.forEach(b => {
                if (b.slidingX === 0 && b.slidingY === 0) {
                    let dist = Math.hypot(player.x - (b.c * TILE_SIZE + TILE_SIZE/2), player.y - (b.r * TILE_SIZE + TILE_SIZE/2));
                    if (dist < TILE_SIZE * 0.8) {
                        if (keys['ArrowRight'] && player.dx > 0 && player.x < (b.c*TILE_SIZE)) b.slidingX = 1;
                        else if (keys['ArrowLeft'] && player.dx < 0 && player.x > (b.c*TILE_SIZE + TILE_SIZE)) b.slidingX = -1;
                        else if (keys['ArrowDown'] && player.dy > 0 && player.y < (b.r*TILE_SIZE)) b.slidingY = 1;
                        else if (keys['ArrowUp'] && player.dy < 0 && player.y > (b.r*TILE_SIZE + TILE_SIZE)) b.slidingY = -1;
                    }
                }
            });
        }

        // --- ç‚¸å½ˆæ›´æ–° ---
        for (let i = bombs.length - 1; i >= 0; i--) {
            let b = bombs[i];
            
            // æ»‘å‹•
            if (b.slidingX !== 0 || b.slidingY !== 0) {
                if (!b.slideCounter) b.slideCounter = 0;
                b.slideCounter++;
                if (b.slideCounter > 4) {
                    let nc = b.c + b.slidingX;
                    let nr = b.r + b.slidingY;
                    let nextTile = getTile(nc, nr);
                    let hasBomb = bombs.some(obs => obs.c === nc && obs.r === nr);
                    let hasEnemy = enemies.some(e => e.c === nc && e.r === nr);
                    
                    if (nextTile === TYPES.FLOOR && !hasBomb && !hasEnemy) {
                        b.c = nc; b.r = nr;
                    } else {
                        b.slidingX = 0; b.slidingY = 0;
                    }
                    b.slideCounter = 0;
                }
            }

            // 3D åŒæ­¥ä½ç½®
            if (meshes.bombs.has(b.id)) {
                const mesh = meshes.bombs.get(b.id);
                const wPos = logicToWorld(b.c * TILE_SIZE, b.r * TILE_SIZE);
                // å¹³æ»‘ç§»å‹•
                mesh.position.x += (wPos.x - mesh.position.x) * 0.5;
                mesh.position.z += (wPos.z - mesh.position.z) * 0.5;
                
                // è„ˆå‹•
                let scale = 1 + Math.sin(Date.now() / 100) * 0.1;
                mesh.scale.set(scale, scale, scale);
            }

            b.timer--;
            if (b.timer <= 0) explodeBomb(b);
        }

        // --- æ•µäººæ›´æ–° ---
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            
            // 3D å»ºç«‹
            if (!meshes.enemies.has(e.id)) {
                meshes.enemies.set(e.id, createEnemyMesh(e.type));
            }

            // ç§»å‹•é‚è¼¯ (åŒ 2D)
            let dirs = [[0,-1], [0,1], [-1,0], [1,0]];
            let move = dirs[e.dir];
            let newX = e.x + move[0] * e.speed;
            let newY = e.y + move[1] * e.speed;
            let cr = toGrid(newY), cc = toGrid(newX);
            let tile = getTile(cc, cr);
            let hitBomb = bombs.some(b => b.c === cc && b.r === cr);
            
            if (tile !== TYPES.FLOOR || hitBomb) {
                e.dir = Math.floor(Math.random() * 4);
            } else {
                if (e.dir < 2) { e.x = snapCenter(e.x); e.y = newY; }
                else { e.x = newX; e.y = snapCenter(e.y); }
                e.c = toGrid(e.x); e.r = toGrid(e.y);
            }

            // ç¢°ç©å®¶
            if (Math.hypot(e.x - player.x, e.y - player.y) < TILE_SIZE * 0.8) gameOver();

            // 3D åŒæ­¥
            const mesh = meshes.enemies.get(e.id);
            if (mesh) {
                const wPos = logicToWorld(e.x, e.y); // æ³¨æ„é€™è£¡çš„ e.x å·²ç¶“æ˜¯ä¸­å¿ƒé»åƒç´ 
                // é€™è£¡æœ‰é» trickï¼Œå› ç‚º logicToWorld æœƒå†åŠ åŠæ ¼ï¼Œä½† e.x å·²ç¶“æ˜¯åƒç´ ä¸­å¿ƒ
                // æˆ‘å€‘ç›´æ¥ç”¨åƒç´ æ›ç®—
                mesh.position.x = (e.x / TILE_SIZE) * UNIT_SIZE + MAP_OFFSET_X; // ä¸å†åŠ  UNIT_SIZE/2 å› ç‚º e.x å·²ç¶“ç½®ä¸­
                mesh.position.z = (e.y / TILE_SIZE) * UNIT_SIZE + MAP_OFFSET_Z;
                
                // å²èŠå§†è·³å‹•
                mesh.position.y = Math.abs(Math.sin(Date.now() / 150)) * 0.5;
                
                // è½‰å‘
                if (e.dir === 2) mesh.rotation.y = -Math.PI/2;
                if (e.dir === 3) mesh.rotation.y = Math.PI/2;
            }

            // ç¢°çˆ†ç‚¸ (æª¢æŸ¥ Mesh æˆ– é‚è¼¯)
            // é€™è£¡ç”¨é‚è¼¯åˆ¤å®š
            let hitExplosion = false;
            meshes.explosions.forEach(exObj => {
               // ç°¡å–®æª¢æŸ¥è·é›¢
               if (Math.abs(exObj.mesh.position.x - mesh.position.x) < 2 && 
                   Math.abs(exObj.mesh.position.z - mesh.position.z) < 2) {
                   hitExplosion = true;
               }
            });
            
            if (hitExplosion) {
                enemies.splice(i, 1);
                scene.remove(mesh);
                meshes.enemies.delete(e.id);
                updateHUD();
            }
        }

        // --- çˆ†ç‚¸ç‰¹æ•ˆæ›´æ–° ---
        for (let i = meshes.explosions.length - 1; i >= 0; i--) {
            let ex = meshes.explosions[i];
            ex.life--;
            ex.mesh.scale.setScalar(1 + (30-ex.life)/10); // è®Šå¤§
            ex.mesh.children.forEach(c => {
                if(c.material.transparent) c.material.opacity = ex.life / 30;
            });
            
            if (ex.life <= 0) {
                scene.remove(ex.mesh);
                meshes.explosions.splice(i, 1);
            }
        }

        // --- å‡ºå£èˆ‡é“å…·é¡¯ç¤º ---
        if (exitPos.revealed && !exitPos.mesh) {
            exitPos.mesh = createExitMesh(exitPos.y, exitPos.x);
        }
        items.forEach(it => {
            if (!it.hidden && !meshes.items.has(it.id)) {
                meshes.items.set(it.id, createItemMesh(it.type));
                const m = meshes.items.get(it.id);
                const wPos = logicToWorld(it.x * TILE_SIZE, it.y * TILE_SIZE);
                m.position.set(wPos.x, 0, wPos.z);
            }
        });
        // é“å…·æ—‹è½‰
        meshes.items.forEach(m => {
            m.rotation.y += 0.05;
            m.position.y = Math.sin(Date.now() / 200) * 0.5;
        });

        // --- ç²’å­æ›´æ–° ---
        for(let i=meshes.particles.length-1; i>=0; i--) {
            let p = meshes.particles[i];
            p.mesh.position.x += p.velocity.x;
            p.mesh.position.y += p.velocity.y;
            p.mesh.position.z += p.velocity.z;
            p.velocity.y -= 0.02; // é‡åŠ›
            if(p.mesh.position.y < 0) p.velocity.y = -p.velocity.y * 0.5; // åœ°æ¿åå½ˆ
            
            p.life--;
            if(p.life <= 0) {
                scene.remove(p.mesh);
                meshes.particles.splice(i, 1);
            }
        }

        // --- å‹åˆ© ---
        if (enemies.length === 0 && exitPos.revealed) {
            const wPos = logicToWorld(player.x, player.y); // é€™æ˜¯åƒç´ ä¸­å¿ƒ
            // è½‰æˆä¸–ç•Œåº§æ¨™å°æ¯”
            const exitWPos = logicToWorld(exitPos.x * TILE_SIZE, exitPos.y * TILE_SIZE);
            if (Math.abs(wPos.x - exitWPos.x) < 2 && Math.abs(wPos.z - exitWPos.z) < 2) {
                gameWin();
            }
        }
    }

    renderer.render(scene, camera);
}

// å•Ÿå‹•
initThree();
startBtn.addEventListener('click', () => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    resetGame();
});

// åˆå§‹ç›¸æ©Ÿæ—‹è½‰ä¸€ä¸‹ä½œç‚ºå±•ç¤º
let angle = 0;
function introLoop() {
    if (!gameRunning) {
        angle += 0.005;
        camera.position.x = Math.sin(angle) * 35;
        camera.position.z = Math.cos(angle) * 35;
        camera.lookAt(0, 0, 0);
        renderer.render(scene, camera);
        requestAnimationFrame(introLoop);
    }
}
introLoop();

</script>
</body>
</html>
